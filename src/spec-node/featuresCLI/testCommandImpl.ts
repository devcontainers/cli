import path from 'path';
import chalk from 'chalk';
import { tmpdir } from 'os';
import * as jsonc from 'jsonc-parser';
import { CLIHost } from '../../spec-common/cliHost';
import { launch, ProvisionOptions, createDockerParams } from '../devContainers';
import { doExec } from '../devContainersSpecCLI';
import { LaunchResult, staticExecParams, staticProvisionParams, testLibraryScript } from './utils';
import { DockerResolverParameters } from '../utils';
import { DevContainerConfig } from '../../spec-configuration/configuration';
import { FeaturesTestCommandInput } from './test';
import { cpDirectoryLocal } from '../../spec-utils/pfs';
import { nullLog } from '../../spec-utils/log';

const TEST_LIBRARY_SCRIPT_NAME = 'dev-container-features-test-lib';

function fail(msg: string) {
	log(msg, { prefix: '[-]', error: true });
	process.exit(1);
}

type Scenarios = { [key: string]: DevContainerConfig };
type TestResult = { testName: string; result: boolean };

function log(msg: string, options?: { omitPrefix?: boolean; prefix?: string; info?: boolean; error?: boolean }) {

	const prefix = options?.prefix || '> ';
	const output = `${options?.omitPrefix ? '' : `${prefix} `}${msg}\n`;

	if (options?.error) {
		process.stdout.write(chalk.red(output));
	} else if (options?.info) {
		process.stdout.write(chalk.bold.blue(output));
	} else {
		process.stdout.write(chalk.blue(output));
	}
}

export async function doFeaturesTestCommand(args: FeaturesTestCommandInput): Promise<number> {
	const { pkg, globalScenariosOnly, features, collectionFolder, cliHost } = args;

	process.stdout.write(`
‚îå ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îê
|    Dev Container Features   |   
‚îÇ           v${pkg.version}           ‚îÇ
‚îî ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îò\n\n`);


	const srcDir = `${collectionFolder}/src`;
	const testsDir = `${collectionFolder}/test`;

	if (! await cliHost.isFolder(srcDir) || ! await cliHost.isFolder(testsDir)) {
		fail(`Folder '${collectionFolder}' does not contain the required 'src' and 'test' folders.`);
	}

	let testResults: TestResult[] = [];
	if (globalScenariosOnly) {
		await runGlobalFeatureTests(args, testResults);
	} else {
		await runFeatureTests(args, testResults);

		// If any features were explictily set to run,
		// we know we don't want to run the global tests.
		if (!features) {
			await runGlobalFeatureTests(args, testResults);
		}
	}

	// Pretty-print test results and exit with 0 or 1 exit code.
	return analyzeTestResults(testResults);
}

async function runGlobalFeatureTests(args: FeaturesTestCommandInput, testResults: TestResult[] = []): Promise<TestResult[]> {
	const { collectionFolder } = args;

	const globalTestsFolder = `${collectionFolder}/test/_global`;

	log(`Scenarios:         ${globalTestsFolder}\n`, { prefix: '\nüìä', info: true });
	testResults = await doScenario(globalTestsFolder, '_global', args, testResults);
	if (!testResults) {
		fail(`Failed to run scenarios in ${globalTestsFolder}`);
		return []; // We never reach here, we exit via fail().
	}

	return testResults;
}


async function runFeatureTests(args: FeaturesTestCommandInput, testResults: TestResult[] = []): Promise<TestResult[]> {
	const { baseImage, collectionFolder, remoteUser, cliHost, skipAutogenerated, skipScenarios } = args;
	let { features } = args;

	const testsDir = `${collectionFolder}/test`;

	log(`baseImage:         ${baseImage}`);
	log(`Target Folder:     ${collectionFolder}`);

	// Parse comma separated list of features
	// If a set of '--features' isn't specified, run all features with a 'test' subfolder in random order.
	if (!features) {
		// Auto-detect
		features =
			(await cliHost.readDir(testsDir))
				.filter(f => f !== '_global'); // Exclude any folder named '_global'

		if (features.length === 0) {
			fail(`No features specified and no test folders found in '${testsDir}'`);
		}
	}

	log(`features:          ${features.join(', ')}`);

	let workspaceFolder: string | undefined = undefined;
	let params: DockerResolverParameters | undefined = undefined;
	if (!skipAutogenerated) {
		// 1. Generate temporary project with 'baseImage' and all the 'features..'
		workspaceFolder = await generateDefaultProjectFromFeatures(
			cliHost,
			baseImage,
			collectionFolder,
			features,
			remoteUser
		);

		params = await generateDockerParams(workspaceFolder, args);
		await createContainerFromWorkingDirectory(params, workspaceFolder, args);
	}

	log('Starting test(s)...\n', { prefix: '\nüèÉ', info: true });

	// 3. Exec default 'test.sh' script for each feature, in the provided order.
	//    Also exec a test's test scenarios, if a scenarios.json is present in the feature's test folder.
	for (const feature of features) {
		log(`Starting '${feature}' tests...`, { prefix: 'üß™' });
		const featureTestFolder = path.join(collectionFolder, 'test', feature);

		if (!skipAutogenerated) {
			if (!workspaceFolder || !params) {
				fail('Uninitialized workspaceFolder or params');
				return [];
			}
			await doRunAutoTest(feature, workspaceFolder, featureTestFolder, args, testResults);
		}

		// If there is a feature-scoped 'scenarios.json' with additional tests, also exec those.
		// Pass  'testResults' array reference in to capture results.
		if (!skipScenarios) {
			log(`Executing scenarios for feature '${feature}'...`, { prefix: 'üß™' });
			await doScenario(featureTestFolder, feature, args, testResults);
		}

		if (!testResults) {
			fail(`Failed to run tests`);
			return []; // We never reach here, we exit via fail().
		}
	}
	return testResults;
}

async function doRunAutoTest(feature: string, workspaceFolder: string, featureTestFolder: string, args: FeaturesTestCommandInput, testResults: TestResult[] = []): Promise<TestResult[]> {
	const { cliHost } = args;
	const testScriptPath = path.join(featureTestFolder, 'test.sh');
	if (!(await cliHost.isFile(testScriptPath))) {
		fail(`Could not find test.sh script at ${testScriptPath}`);
	}

	// Move the entire test directory for the given Feature into the workspaceFolder
	await cpDirectoryLocal(featureTestFolder, workspaceFolder, {dereference: true});

	// Move the test library script into the workspaceFolder test scripts folder.
	await cliHost.writeFile(path.join(workspaceFolder, TEST_LIBRARY_SCRIPT_NAME), Buffer.from(testLibraryScript));

	// Execute Test
	const result = await execTest(args, 'test.sh', workspaceFolder, cliHost);
	testResults.push({
		testName: feature,
		result,
	});

	return testResults;
}

async function doScenario(pathToTestDir: string, targetFeatureOrGlobal: string, args: FeaturesTestCommandInput, testResults: TestResult[] = []): Promise<TestResult[]> {
	const { collectionFolder, cliHost, filter } = args;
	const scenariosPath = path.join(pathToTestDir, 'scenarios.json');

	if (!(await cliHost.isFile(scenariosPath))) {
		log(`No scenario file found at '${scenariosPath}'. Skipping...`, { prefix: '‚ö†Ô∏è', });
		return testResults;
	}

	// Read in scenarios.json
	const scenariosBuffer = await cliHost.readFile(scenariosPath);
	// Parse to json
	let scenarios: Scenarios = {};
	let errors: jsonc.ParseError[] = [];
	scenarios = jsonc.parse(scenariosBuffer.toString(), errors);
	if (errors.length > 0) {
		// Print each jsonc error
		errors.forEach(error => {
			log(`${jsonc.printParseErrorCode(error.error)}`, { prefix: '‚ö†Ô∏è' });
		});
		fail(`Failed to parse scenarios.json at ${scenariosPath}`);
		return []; // We never reach here, we exit via fail()
	}

	// For EACH scenario: Spin up a container and exec the scenario test script
	for (const [scenarioName, scenarioConfig] of Object.entries(scenarios)) {

		if (filter && !scenarioName.includes(filter)) {
			continue;
		}

		log(`Running scenario:  ${scenarioName}`);

		// Check if we have a scenario test script, otherwise skip.
		if (!(await cliHost.isFile(path.join(pathToTestDir, `${scenarioName}.sh`)))) {
			fail(`No scenario test script found at path '${path.join(pathToTestDir, `${scenarioName}.sh`)}'.  Either add a script to the test folder, or remove from scenarios.json.`);
		}

		// Create Container
		const workspaceFolder = await generateProjectFromScenario(cliHost, collectionFolder, scenarioName, scenarioConfig, targetFeatureOrGlobal);
		const params = await generateDockerParams(workspaceFolder, args);
		await createContainerFromWorkingDirectory(params, workspaceFolder, args);

		// Move the entire test directory for the given Feature into the workspaceFolder
		await cpDirectoryLocal(pathToTestDir, workspaceFolder, {dereference: true});

		// Move the test library script into the workspaceFolder
		await cliHost.writeFile(path.join(workspaceFolder, TEST_LIBRARY_SCRIPT_NAME), Buffer.from(testLibraryScript));

		// Execute Test
		testResults.push({
			testName: scenarioName,
			result: await execTest(args, `${scenarioName}.sh`, workspaceFolder, cliHost)
		});
	}
	return testResults;
}

function analyzeTestResults(testResults: { testName: string; result: boolean }[]): number {
	if (!testResults) {
		fail('No test results found!');
	}
	// 4. Print results
	// NOTE: 0 tests means allPassed == true.
	const allPassed = testResults.every((x) => x.result);
	process.stdout.write('\n\n\n');
	log('================== TEST REPORT ==================', { 'info': true, 'prefix': ' ' });
	testResults.forEach(t => {
		if (t.result) {
			log(`Passed:      '${t.testName}'`, { 'prefix': '‚úÖ', 'info': true });
		} else {
			log(`Failed:      '${t.testName}'`, { 'prefix': '‚ùå', 'info': true });
		}
	});
	process.stdout.write('\n');
	return allPassed ? 0 : 1;
}

const devcontainerTemplate = `
{
	#{REMOTE_USER}
	"image": "#{IMAGE}",
	"features": {
		#{FEATURES}
	}
}`;

async function createContainerFromWorkingDirectory(params: DockerResolverParameters, workspaceFolder: string, args: FeaturesTestCommandInput): Promise<LaunchResult | undefined> {
	const { quiet, disposables } = args;
	log(`workspaceFolder:   ${workspaceFolder}`);

	// 2. Use  'devcontainer-cli up'  to build and start a container
	log('Building test container...\n', { prefix: '\n‚è≥', info: true });
	const launchResult: LaunchResult | undefined = await launchProject(params, args, workspaceFolder, quiet, disposables);
	if (!launchResult || !launchResult.containerId) {
		fail('Failed to launch container');
		return;
	}

	const { containerId } = launchResult;

	log(`Launched container.`, { prefix: '\nüöÄ', info: true });
	log(`containerId:          ${containerId}`);

	return launchResult;
}

async function createTempDevcontainerFolder(cliHost: CLIHost): Promise<string> {
	const systemTmpDir = tmpdir();
	const tmpFolder = path.join(systemTmpDir, 'devcontainercli', 'container-features-test', Date.now().toString());
	await cliHost.mkdirp(`${tmpFolder}/.devcontainer`);
	return tmpFolder;
}

async function generateDefaultProjectFromFeatures(
	cliHost: CLIHost,
	baseImage: string,
	collectionsDirectory: string,
	featuresToTest: string[],
	remoteUser: string | undefined
): Promise<string> {
	const tmpFolder = await createTempDevcontainerFolder(cliHost);

	const features = featuresToTest
		.map((x) => `"./${x}": {}`)
		.join(',\n');

	for (const featureId of featuresToTest) {
		// Copy the feature source code to the temp folder
		const pathToFeatureSource = `${collectionsDirectory}/src/${featureId}`;
		await cpDirectoryLocal(pathToFeatureSource, `${tmpFolder}/.devcontainer/${featureId}`, {dereference: true});
	}

	let template = devcontainerTemplate
		.replace('#{IMAGE}', baseImage)
		.replace('#{FEATURES}', features);

	if (remoteUser) {
		template = template.replace('#{REMOTE_USER}', `"remoteUser": "${remoteUser}",`);
	} else {
		template = template.replace('#{REMOTE_USER}', '');
	}

	await cliHost.writeFile(`${tmpFolder}/.devcontainer/devcontainer.json`, Buffer.from(template));

	return tmpFolder;
}

async function generateProjectFromScenario(
	cliHost: CLIHost,
	collectionsDirectory: string,
	scenarioId: string,
	scenarioObject: DevContainerConfig,
	targetFeatureOrGlobal: string
): Promise<string> {
	const tmpFolder = await createTempDevcontainerFolder(cliHost);

	let features = scenarioObject.features;
	if (!scenarioObject || !features) {
		fail(`Scenario '${scenarioId}' is missing Features!`);
		return ''; // Exits in the 'fail()' before this line is reached.
	}

	// Prefix the local path to the collections directory
	let updatedFeatures: Record<string, string | boolean | Record<string, string | boolean>> = {};
	for (const [featureId, featureValue] of Object.entries(features)) {
		// Do not overwrite Features that are not part of the target collection
		// The '/' is only valid in a fully qualified Feature ID (eg: '[ghcr].io/devcontainers/features/go')
		// This lets you use external Features as a part of the test scenario.
		if (featureId.indexOf('/') !== -1) {
			updatedFeatures[featureId] = featureValue;
			continue;
		}

		// Copy the feature source code to the temp folder
		const pathToFeatureSource = `${collectionsDirectory}/src/${featureId}`;
		await cpDirectoryLocal(pathToFeatureSource, `${tmpFolder}/.devcontainer/${featureId}`, {dereference: true});

		// Reference Feature in the devcontainer.json
		updatedFeatures[`./${featureId}`] = featureValue;
	}
	scenarioObject.features = updatedFeatures;

	await cliHost.writeFile(`${tmpFolder}/.devcontainer/devcontainer.json`, Buffer.from(JSON.stringify(scenarioObject)));

	// If the current scenario has a corresponding additional config folder, copy it into the $TMP/.devcontainer directory
	// This lets the scenario use things like Dockerfiles, shell scripts, etc. in the build.
	const localPathToAdditionalConfigFolder = `${collectionsDirectory}/test/${targetFeatureOrGlobal}/${scenarioId}`;
	if (await cliHost.isFolder(localPathToAdditionalConfigFolder)) {
		await cpDirectoryLocal(localPathToAdditionalConfigFolder, `${tmpFolder}/.devcontainer`, {dereference: true});
	}

	// Update permissions on the copied files to make them readable/writable/executable by everyone
	await cliHost.exec({ cmd: 'chmod', args: ['-R', '777', tmpFolder], output: nullLog });

	// tmpFolder will serve as our auto-generated 'workingFolder'
	return tmpFolder;
}

async function launchProject(params: DockerResolverParameters, args: FeaturesTestCommandInput, workspaceFolder: string, quiet: boolean, disposables: (() => Promise<unknown> | undefined)[]): Promise<LaunchResult> {
	const { common } = params;
	let response = {} as LaunchResult;

	const idLabels = [ `devcontainer.local_folder=${workspaceFolder}` ];
	const options: ProvisionOptions = {
		...staticProvisionParams,
		workspaceFolder,
		logLevel: common.getLogLevel(),
		mountWorkspaceGitRoot: true,
		remoteEnv: common.remoteEnv,
		skipFeatureAutoMapping: common.skipFeatureAutoMapping,
		experimentalImageMetadata: !args.skipImageMetadata,
		skipPersistingCustomizationsFromFeatures: common.skipPersistingCustomizationsFromFeatures,
		log: text => quiet ? null : process.stderr.write(text),
		dotfiles: {}
	};

	try {
		if (quiet) {
			// Launch container but don't await it to reduce output noise
			let isResolved = false;
			const p = launch(options, idLabels, disposables);
			p.then(function (res) {
				process.stdout.write('\n');
				response = res;
				isResolved = true;
			});
			while (!isResolved) {
				// Just so visual progress with dots
				process.stdout.write('.');
				await new Promise((resolve) => setTimeout(resolve, 500));
			}
		} else {
			// Stream all the container setup logs.
			response = await launch(options, idLabels, disposables);
		}

		return {
			...response,
			disposables,
		};
	} catch (e: any) {
		fail(`Failed to launch container:\n\n${e?.message ?? 'Unknown error'}`);
		return response; // `fail` exits before we return this.
	}
}

async function execTest(testCommandArgs: FeaturesTestCommandInput, testFileName: string, workspaceFolder: string, cliHost: CLIHost) {
	// Ensure all the tests scripts in the workspace folder are executable
	// Update permissions on the copied files to make them readable/writable/executable by everyone
	await cliHost.exec({ cmd: 'chmod', args: ['-R', '777', workspaceFolder], output: nullLog });

	const cmd = `./${testFileName}`;
	const args: string[] = [];
	return await exec(testCommandArgs, cmd, args, workspaceFolder);
}

async function exec(testCommandArgs: FeaturesTestCommandInput, cmd: string, args: string[], workspaceFolder: string) {
	const execArgs = {
		...staticExecParams,
		'workspace-folder': workspaceFolder,
		'skip-feature-auto-mapping': false,
		'experimental-image-metadata': !testCommandArgs.skipImageMetadata,
		cmd,
		args,
		_: [
			cmd,
			...args
		]
	};
	const result = await doExec(execArgs);
	return (result.outcome === 'success');
}

async function generateDockerParams(workspaceFolder: string, args: FeaturesTestCommandInput): Promise<DockerResolverParameters> {
	const { logLevel, quiet, disposables } = args;
	return await createDockerParams({
		workspaceFolder,
		dockerPath: undefined,
		dockerComposePath: undefined,
		containerDataFolder: undefined,
		containerSystemDataFolder: undefined,
		mountWorkspaceGitRoot: false,
		configFile: undefined,
		overrideConfigFile: undefined,
		logLevel,
		logFormat: 'text',
		log: text => quiet ? null : process.stderr.write(text),
		terminalDimensions: undefined,
		defaultUserEnvProbe: 'loginInteractiveShell',
		removeExistingContainer: false,
		buildNoCache: false,
		expectExistingContainer: false,
		postCreateEnabled: false,
		skipNonBlocking: false,
		prebuild: false,
		persistedFolder: undefined,
		additionalMounts: [],
		updateRemoteUserUIDDefault: 'never',
		remoteEnv: {},
		additionalCacheFroms: [],
		omitLoggerHeader: true,
		useBuildKit: 'auto',
		buildxPlatform: undefined,
		buildxPush: false,
		buildxOutput: undefined,
		skipFeatureAutoMapping: false,
		skipPostAttach: false,
		skipPersistingCustomizationsFromFeatures: false,
		experimentalImageMetadata: !args.skipImageMetadata,
		dotfiles: {}
	}, disposables);
}
